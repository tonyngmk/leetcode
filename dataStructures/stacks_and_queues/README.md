### 1. Design Circular Queue Template
- File: `design_circular_queue.py`
- Link: https://leetcode.com/explore/learn/card/queue-stack/228/first-in-first-out-data-structure/1337/
- Description: To design the attributes for a circular queue using an array using head and tail index.
- Pattern: NIL
- Time: NIL
- Space: NIL
- Difficulty: 4/10, to retry without help

### 2. Moving Average from Data Stream
- File: `moving_average_from_data_stream.py`
- Link: https://leetcode.com/problems/moving-average-from-data-stream/
- Description: To implement deque (double-ended queue) or better circular queue using array. 
- Pattern: Deque or circular queue using array.
- Time: O(1)
- Space: O(N)
- Difficulty: 3/10, to retry without help


### 3. Walls and Gates
- File: `walls_and_gates.py`
- Link: https://leetcode.com/problems/walls-and-gates/solution/
- Description: Rewrite the input array and mark empty rooms with the step to closest gate
- Pattern: To use BFS from all gates per step
- Time: O(m*n)
- Space: O(m*n)
- Difficulty: 5/10

### 5. Number of Islands
- File: `number_of_islands.py`
- Link: https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1374/
- Description: To return the amount of valid islands denoted by "1"
- Pattern: For each valid island of value "1", perform BFS unless it belongs to visited.
- Time: O(m*n)
- Space: O(m*n)
- Difficulty: 5/10

### 6. Open the lock
- File: `open_the_lock.py`
- Link: https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1375/
- Description: To find the minimum number of steps
- Pattern: Find all possible ways in a single step with BFS, in this way we will definitely get minimum depth.
- Time: O(N^2 * A^N + D), where N is the length of lock (4), A is the range for each slot (10), D is the number of deadends (variable).
- Space: O(A^N + D), to store all combinations including an additional set for deadends.
- Difficulty: 5/10

### 6. Open the lock
- File: `open_the_lock.py`
- Link: https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1375/
- Description: To find the minimum number of steps
- Pattern: Find all possible ways in a single step with BFS, in this way we will definitely get minimum depth.
- Time: O(N^2 * A^N + D), where N is the length of lock (4), A is the range for each slot (10), D is the number of deadends (variable).
- Space: O(A^N + D), to store all combinations including an additional set for deadends.
- Difficulty: 5/10

---
### Template
- File: `.py`
- Link: 
- Description: 
- Pattern: 
- Time: 
- Space: 
- Difficulty: /10
